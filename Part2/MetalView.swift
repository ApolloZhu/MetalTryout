//
//  MetalView.swift
//  MetalTryout
//
//  Created by Apollo Zhu on 4/27/17.
//  Copyright Â© 2017 WWITDC. All rights reserved.
//

//  Tutorial: http://metalkit.org/2016/01/18/using-metalkit-part-2.html

import Cocoa
import MetalKit

extension MTLClearColor {
    /// The color generated by blending blue and green.
    static let bleen = MTLClearColor(red: 0, green: 0.5, blue: 0.5, alpha: 1)
}

class MetalView: MTKView {
    required init(coder: NSCoder) {
        super.init(coder: coder)
        device = MTLCreateSystemDefaultDevice()
    }
    
    lazy var cmdQueue: MTLCommandQueue = self.device!.makeCommandQueue()!
    
    /// Buffer of vertices for shaders.
    lazy var vertexBuffer: MTLBuffer = {
        // float4: 3 floats representing (x,y,z), and the other is 
        // the w axis, for a perspective system called homogeneous coordinates, 
        // describing the distance from the view point.
        let vertexData: [Float] = [
            -1.0, -1.0, 0.0, 1.0, // bottom left
             1.0, -1.0, 0.0, 1.0, // bottom right
             0.0,  1.0, 0.0, 1.0  // top center
        ]
        let length = vertexData.count * MemoryLayout<Float>.size
        return self.device!.makeBuffer(bytes: vertexData, length: length)!
    }()
    
    /// Instructions for the rendering pipeline.
    lazy var renderPipelineState: MTLRenderPipelineState = {
        // Contents of the `.metal` files within the project.
        let library = self.device!.makeDefaultLibrary()!
        // Information describing the entire rendering process.
        let descriptor = MTLRenderPipelineDescriptor()
        // Load function in shader file for calculating location of vertices
        descriptor.vertexFunction = library.makeFunction(name: "vertex_function")
        // Load function in shader file for calculating fragment, the color of a vertex
        descriptor.fragmentFunction = library.makeFunction(name: "fragment_function")
        // The color is returned as 8-bit normalized unsigned interger, ordered as blue-green-red-alpha
        descriptor.colorAttachments[0].pixelFormat = .bgra8Unorm
        return try! self.device!.makeRenderPipelineState(descriptor: descriptor)
    }()
    
    
    override func draw(_ dirtyRect: NSRect) {
        super.draw(dirtyRect)
        
        guard let drawable = currentDrawable
            , let descriptor = currentRenderPassDescriptor
            else { return }
        // We are not just clearing everytime, so keep with default
        descriptor.colorAttachments[0].clearColor = .bleen
        let cmdBuffer = cmdQueue.makeCommandBuffer()!
        let encoder = cmdBuffer.makeRenderCommandEncoder(descriptor: descriptor)!
        
        // Configure vertex buffer and render pipeline state
        encoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)
        encoder.setRenderPipelineState(renderPipelineState)
        // Draw the triangle.
        encoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3)
        
        encoder.endEncoding()
        cmdBuffer.present(drawable)
        cmdBuffer.commit()
    }
}
